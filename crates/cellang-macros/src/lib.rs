use proc_macro::TokenStream;
use proc_macro2::{Span, TokenStream as TokenStream2};
use quote::{quote, ToTokens};
use syn::spanned::Spanned;
use syn::{
    parse_macro_input, Attribute, Data, DeriveInput, Expr, Fields, Ident,
    LitStr, Type,
};

#[proc_macro_derive(CelStruct, attributes(cel))]
pub fn derive_cel_struct(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    match expand(input) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

struct StructAttrs {
    type_name: LitStr,
    doc: Option<LitStr>,
}

struct FieldAttrs {
    rename: Option<LitStr>,
    doc: Option<LitStr>,
    ty_override: Option<Expr>,
}

struct FieldInfo {
    ident: Ident,
    cel_name: LitStr,
    rust_ty: Type,
    ty_tokens: TokenStream2,
    doc: Option<LitStr>,
    into_value: TokenStream2,
}

fn expand(input: DeriveInput) -> syn::Result<TokenStream2> {
    let name = input.ident.clone();
    if !input.generics.params.is_empty() {
        return Err(syn::Error::new(
            input.generics.span(),
            "CelStruct does not support generic structs",
        ));
    }

    let attrs = parse_struct_attrs(&input.attrs)?;
    let fields = match input.data {
        Data::Struct(data) => match data.fields {
            Fields::Named(fields) => fields.named,
            _ => {
                return Err(syn::Error::new(
                    data.struct_token.span,
                    "CelStruct expects a struct with named fields",
                ))
            }
        },
        _ => {
            return Err(syn::Error::new(
                input.span(),
                "CelStruct can only be derived for structs",
            ))
        }
    };

    let mut field_infos = Vec::new();
    for field in fields {
        let ident = field.ident.expect("named fields checked above");
        let field_attrs = parse_field_attrs(&field.attrs)?;
        let cel_name = field_attrs
            .rename
            .unwrap_or_else(|| LitStr::new(&ident.to_string(), ident.span()));
        let ty_tokens = if let Some(expr) = field_attrs.ty_override {
            quote! { (#expr) }
        } else {
            map_type(&field.ty)?
        };
        let into_value = into_value_expr(&ident, &field.ty);
        field_infos.push(FieldInfo {
            ident,
            cel_name,
            rust_ty: field.ty,
            ty_tokens,
            doc: field_attrs.doc,
            into_value,
        });
    }

    let doc_tokens = attrs.doc.map(|doc| quote! { ty = ty.with_doc(#doc); });
    let struct_fields = field_infos.iter().map(|info| {
        let FieldInfo {
            cel_name,
            ty_tokens,
            doc,
            ..
        } = info;
        let doc_tokens = doc.as_ref().map(|doc| quote! { field = field.with_doc(#doc); });
        quote! {
            let mut field = cellang::types::FieldDecl::new(#ty_tokens);
            #doc_tokens
            ty.add_field(#cel_name, field)
                .expect("duplicate field generated by CelStruct derive");
        }
    });

    let into_value_fields = field_infos.iter().map(|info| {
        let field_name = &info.cel_name;
        let into_value = &info.into_value;
        quote! {
            value.set_field(#field_name, #into_value);
        }
    });

    let try_from_fields = field_infos.iter().map(|info| {
        let ident = &info.ident;
        let field_name = &info.cel_name;
        let rust_ty = &info.rust_ty;
        quote! {
            let #ident = {
                let value = strct.get(#field_name).ok_or_else(|| {
                    cellang::value::ValueError::Message(format!(
                        "{}.{} is missing",
                        <Self as cellang::CelType>::CEL_TYPE_NAME,
                        #field_name,
                    ))
                })?;
                <#rust_ty as cellang::value::TryFromValue>::try_from_value(value)?
            };
        }
    });

    let field_idents = field_infos.iter().map(|info| &info.ident);
    let type_name = attrs.type_name;

    Ok(quote! {
        impl cellang::CelType for #name {
            const CEL_TYPE_NAME: &'static str = #type_name;

            fn cel_type() -> cellang::types::Type {
                cellang::types::Type::struct_type(Self::CEL_TYPE_NAME)
            }

            fn cel_named_type() -> cellang::types::NamedType {
                let mut ty = cellang::types::StructType::new(Self::CEL_TYPE_NAME);
                #doc_tokens
                #(#struct_fields)*
                cellang::types::NamedType::Struct(ty)
            }

            fn register_cel_type(
                builder: &mut cellang::runtime::RuntimeBuilder,
            ) -> Result<(), cellang::error::EnvError> {
                builder.add_type(Self::cel_named_type()).map(|_| ())
            }
        }

        impl #name {
            pub const CEL_TYPE_NAME: &'static str = <Self as cellang::CelType>::CEL_TYPE_NAME;

            pub fn cel_type() -> cellang::types::Type {
                <Self as cellang::CelType>::cel_type()
            }

            pub fn cel_named_type() -> cellang::types::NamedType {
                <Self as cellang::CelType>::cel_named_type()
            }

            pub fn register_cel_type(
                builder: &mut cellang::runtime::RuntimeBuilder,
            ) -> Result<(), cellang::error::EnvError> {
                <Self as cellang::CelType>::register_cel_type(builder)
            }
        }

        impl cellang::value::IntoValue for #name {
            fn into_value(self) -> cellang::value::Value {
                let mut value = cellang::value::StructValue::new(
                    <Self as cellang::CelType>::CEL_TYPE_NAME,
                );
                #(#into_value_fields)*
                cellang::value::Value::Struct(value)
            }
        }

        impl cellang::value::TryFromValue for #name {
            fn try_from_value(
                value: &cellang::value::Value,
            ) -> Result<Self, cellang::value::ValueError> {
                let cellang::value::Value::Struct(strct) = value else {
                    return Err(cellang::value::ValueError::unexpected(
                        "struct",
                        value.kind(),
                    ));
                };
                if strct.type_name.as_str()
                    != <Self as cellang::CelType>::CEL_TYPE_NAME
                {
                    return Err(cellang::value::ValueError::Message(format!(
                        "expected struct of type '{}' got '{}'",
                        <Self as cellang::CelType>::CEL_TYPE_NAME,
                        strct.type_name,
                    )));
                }
                #(#try_from_fields)*
                Ok(Self {
                    #(#field_idents),*
                })
            }
        }
    })
}

fn into_value_expr(ident: &Ident, ty: &Type) -> TokenStream2 {
    if let Some(inner) = vec_inner_type(ty) {
        if is_u8(inner) {
            quote! { self.#ident }
        } else {
            quote! { cellang::value::ListValue::from(self.#ident) }
        }
    } else {
        quote! { self.#ident }
    }
}

fn vec_inner_type(ty: &Type) -> Option<&Type> {
    if let Type::Path(path) = ty {
        if let Some(segment) = path.path.segments.last() {
            if segment.ident == "Vec" {
                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {
                    if let Some(syn::GenericArgument::Type(inner)) = args.args.first() {
                        return Some(inner);
                    }
                }
            }
        }
    }
    None
}

fn is_u8(ty: &Type) -> bool {
    match ty {
        Type::Path(path) => path
            .path
            .segments
            .last()
            .map(|segment| segment.ident == "u8")
            .unwrap_or(false),
        _ => false,
    }
}

fn parse_struct_attrs(attrs: &[Attribute]) -> syn::Result<StructAttrs> {
    let mut type_name = None;
    let mut doc = None;
    for attr in attrs.iter().filter(|attr| attr.path().is_ident("cel")) {
        attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("type") {
                let lit: LitStr = meta.value()?.parse()?;
                type_name = Some(lit);
                Ok(())
            } else if meta.path.is_ident("doc") {
                let lit: LitStr = meta.value()?.parse()?;
                doc = Some(lit);
                Ok(())
            } else {
                Err(meta.error("unsupported #[cel(..)] attribute"))
            }
        })?;
    }
    let type_name = type_name.ok_or_else(|| syn::Error::new(
        Span::call_site(),
        "missing #[cel(type = \"fully.qualified.Type\")] attribute",
    ))?;
    Ok(StructAttrs { type_name, doc })
}

fn parse_field_attrs(attrs: &[Attribute]) -> syn::Result<FieldAttrs> {
    let mut rename = None;
    let mut doc = None;
    let mut ty_override = None;
    for attr in attrs.iter().filter(|attr| attr.path().is_ident("cel")) {
        attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("rename") {
                let lit: LitStr = meta.value()?.parse()?;
                rename = Some(lit);
                Ok(())
            } else if meta.path.is_ident("doc") {
                let lit: LitStr = meta.value()?.parse()?;
                doc = Some(lit);
                Ok(())
            } else if meta.path.is_ident("type") {
                let expr: Expr = meta.value()?.parse()?;
                ty_override = Some(expr);
                Ok(())
            } else {
                Err(meta.error("unsupported #[cel(..)] attribute on field"))
            }
        })?;
    }
    Ok(FieldAttrs {
        rename,
        doc,
        ty_override,
    })
}

fn map_type(ty: &Type) -> syn::Result<TokenStream2> {
    match ty {
        Type::Reference(reference) => map_type(&reference.elem),
        Type::Path(path) => {
            let segment = path.path.segments.last().ok_or_else(|| {
                syn::Error::new(path.span(), "expected a concrete type for field")
            })?;
            let ident = segment.ident.to_string();
            match ident.as_str() {
                "bool" => Ok(simple_type("Bool")),
                "i32" | "i64" | "isize" => Ok(simple_type("Int")),
                "u32" | "u64" | "usize" => Ok(simple_type("Uint")),
                "f32" | "f64" => Ok(simple_type("Double")),
                "String" => Ok(simple_type("String")),
                "Vec" => match &segment.arguments {
                    syn::PathArguments::AngleBracketed(args) => {
                        if let Some(syn::GenericArgument::Type(inner)) =
                            args.args.first()
                        {
                            let inner_tokens = map_type(inner)?;
                            Ok(quote! { cellang::types::Type::list(#inner_tokens) })
                        } else {
                            Err(syn::Error::new(
                                args.span(),
                                "Vec<T> expects a concrete type argument",
                            ))
                        }
                    }
                    _ => Err(syn::Error::new(
                        segment.ident.span(),
                        "Vec<T> must specify the inner type",
                    )),
                },
                "OffsetDateTime" => Ok(simple_type("Timestamp")),
                "Duration" => Ok(simple_type("Duration")),
                "Value" => Ok(simple_type("Dyn")),
                other => {
                    if other == "Option" {
                        return Err(syn::Error::new(
                            segment.ident.span(),
                            "Option<T> is not supported in CelStruct derive",
                        ));
                    }
                    let ty_tokens = path.to_token_stream();
                    Ok(quote! {
                        <#ty_tokens as cellang::CelType>::cel_type()
                    })
                }
            }
        }
        _ => Err(syn::Error::new(
            ty.span(),
            "Unsupported field type in CelStruct derive",
        )),
    }
}

fn simple_type(name: &str) -> TokenStream2 {
    let ident = Ident::new(name, Span::call_site());
    quote! { cellang::types::Type::#ident }
}
